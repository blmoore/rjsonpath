---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, echo = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "README-"
)
```

# rjsonpath
[![CircleCI](https://dl.circleci.com/status-badge/img/gh/blmoore/rjsonpath/tree/master.svg?style=svg)](https://dl.circleci.com/status-badge/redirect/gh/blmoore/rjsonpath/tree/master)
[![codecov](https://codecov.io/gh/blmoore/rjsonpath/branch/master/graph/badge.svg)](https://codecov.io/gh/blmoore/rjsonpath)
[![docs_badge](https://img.shields.io/badge/docs-latest-blue.svg)](http://blm.io/rjsonpath)
[![CRAN_badge](http://www.r-pkg.org/badges/version/rjsonpath)](https://cran.r-project.org/package=rjsonpath)

Reading JSON into R usually leaves you with some deeply-nested
list objects which are a pain to munge and navigate — applying path
expressions is one way to make this easier. `rjsonpath` implements
[JSONPath](http://goessner.net/articles/JsonPath/), a 
selector / querying language for JSON, similar to XPath for 
XML.

## Install

Install from github with:

```{r eval=FALSE}
devtools::install_github("blmoore/rjsonpath")
```


## Usage

As an example, take this simple JSON:

```{js}
{"menu": {
  "id": "file",
  "value": "File",
  "popup": {
    "menuitem": [
      {"value": "New", "onclick": "CreateNewDoc()"},
      {"value": "Open", "onclick": "OpenDoc()"},
      {"value": "Close", "onclick": "CloseDoc()"}
    ]
  }
}}
```

```{r write_json_object, echo = FALSE}
json <- '{"menu": {
  "id": "file",
  "value": "File",
  "popup": {
    "menuitem": [
      {"value": "New", "onclick": "CreateNewDoc()"},
      {"value": "Open", "onclick": "OpenDoc()"},
      {"value": "Close", "onclick": "CloseDoc()"}
    ]
  }
}}'
json <- jsonlite::fromJSON(json, simplifyVector = FALSE)
library(rjsonpath)
```

Via `read_json` this can be read into R as:

```{r}
json
```

Pretty horrible right? To gather all the `onclick` methods 
into a vector with base R you might write:

```{r}
sapply(json$menu$popup$menuitem, `[[`, "onclick")
```

Using `rjsonpath` this could instead be:

```{r, message=FALSE, eval=FALSE}
# json_path(json, "$.menu.popup.menuitem[*].onclick")
# [1] "CreateNewDoc()" "OpenDoc()"      "CloseDoc()"
```

Or even just:

```{r, message=FALSE, eval=FALSE}
# json_path(json, "$..onclick")
# [1] "CreateNewDoc()" "OpenDoc()"      "CloseDoc()"
```

For more more complex examples, see [below](#Advanced expressions).

## Advanced expressions

For more complex JSON documents it's common to combine filters, array slices
and recursive descent. The following examples use a simple "store" object
similar to the one in the original JSONPath specification:

```{r, echo = FALSE}
store <- jsonlite::fromJSON('{
  "store": {
    "book": [
      {
        "category": "reference",
        "author": "Nigel Rees",
        "title": "Sayings of the Century",
        "price": 8.95
      },
      {
        "category": "fiction",
        "author": "Evelyn Waugh",
        "title": "Sword of Honour",
        "price": 12.99
      },
      {
        "category": "fiction",
        "author": "Herman Melville",
        "title": "Moby Dick",
        "isbn": "0-553-21311-3",
        "price": 8.99
      },
      {
        "category": "fiction",
        "author": "J. R. R. Tolkien",
        "title": "The Lord of the Rings",
        "isbn": "0-395-19395-8",
        "price": 22.99
      }
    ],
    "bicycle": {
      "color": "red",
      "price": 19.95
    }
  }
}', simplifyVector = FALSE)
```

### Filter expressions

Select only books cheaper than 10:

```{r, eval=FALSE}
json_path(store, "$.store.book[?(@.price < 10)].title")
```

Select books that have an `isbn` field:

```{r, eval=FALSE}
json_path(store, "$.store.book[?(@.isbn)].title")
```

### Recursive descent

Get all prices anywhere under `store`:

```{r, eval=FALSE}
json_path(store, "$.store..price")
```

Get all authors anywhere in the document:

```{r, eval=FALSE}
json_path(store, "$..author")
```

### Array slices and unions

Select a slice of books (second and third) and return their titles:

```{r, eval=FALSE}
json_path(store, "$.store.book[1:3].title")
```

Select a non‑contiguous subset of books by index:

```{r, eval=FALSE}
json_path(store, "$.store.book[0,3].title")
```

## Performance

Performance benchmarks on a large JSON object (10,000 element array):

```{r performance, echo = FALSE, message = FALSE, warning = FALSE}
# Generate large test data
generate_large_array <- function(n) {
  lapply(1:n, function(i) {
    list(
      id = i,
      name = paste0("item_", i),
      price = runif(1, 1, 100),
      category = sample(c("fiction", "non-fiction", "tech", "science"), 1),
      rating = sample(1:5, 1),
      in_stock = sample(c(TRUE, FALSE), 1),
      metadata = list(
        created = Sys.time(),
        views = sample(1:10000, 1)
      )
    )
  })
}

# Create large JSON object
large_json <- list(data = generate_large_array(10000))

# Benchmark different operations
if (requireNamespace("microbenchmark", quietly = TRUE)) {
  library(microbenchmark)
  
  # Simple property access
  simple_time <- microbenchmark(
    json_path(large_json, "$.data[*].name"),
    times = 10
  )
  
  # Filter expression
  filter_time <- microbenchmark(
    json_path(large_json, "$.data[?(@.price<50)]"),
    times = 10
  )
  
  # Recursive descent (create nested structure)
  nested_json <- list(
    level1 = list(
      level2 = list(
        level3 = list(
          level4 = list(
            level5 = list(
              target = "found"
            )
          )
        )
      )
    )
  )
  nested_json$level1$level2$level3$target <- "also_found"
  nested_json$level1$target <- "another"
  
  recursive_time <- microbenchmark(
    json_path(nested_json, "$..target"),
    times = 10
  )
  
  # Array slice
  slice_time <- microbenchmark(
    json_path(large_json, "$.data[0:100]"),
    times = 10
  )
  
  # Format results
  cat("| Operation | Median Time | Mean Time |\n")
  cat("|-----------|-------------|-----------|\n")
  cat("| Simple property access (`$.data[*].name`) |", 
      sprintf("%.1f", median(simple_time$time / 1e6)), "ms |",
      sprintf("%.1f", mean(simple_time$time / 1e6)), "ms |\n")
  cat("| Filter expression (`$.data[?(@.price<50)]`) |", 
      sprintf("%.1f", median(filter_time$time / 1e6)), "ms |",
      sprintf("%.1f", mean(filter_time$time / 1e6)), "ms |\n")
  cat("| Recursive descent (`$..target`) |", 
      sprintf("%.2f", median(recursive_time$time / 1e6)), "ms |",
      sprintf("%.2f", mean(recursive_time$time / 1e6)), "ms |\n")
  cat("| Array slice (`$.data[0:100]`) |", 
      sprintf("%.1f", median(slice_time$time / 1e6)), "ms |",
      sprintf("%.1f", mean(slice_time$time / 1e6)), "ms |\n")
} else {
  cat("Install 'microbenchmark' package to see performance benchmarks.\n")
}
```


